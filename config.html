<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Auto Post Discord Configuration</title>
  <link
    href="https://cdn.jsdelivr.net/npm/@tabler/core@latest/dist/css/tabler.min.css"
    rel="stylesheet"
  />
  <link
    href="https://cdn.jsdelivr.net/npm/sweetalert2@11.7.0/dist/sweetalert2.min.css"
    rel="stylesheet"
  />
  <link
    href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
  />
  <style>
    body {
      background-color: #f8f9fa;
      font-family: Arial, sans-serif;
    }
    .truncate {
      max-width: 150px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #pageTitle {
      text-align: center;
      font-family: "Montserrat", sans-serif;
      font-weight: 700;
    }
    .btn-stop,
    .btn-success,
    .saveAuth {
      margin-top: 1.5rem;
    }
  </style>
</head>
<body>
  <div class="container my-4" id="bodys">
    <h3 id="pageTitle">Auto Post Discord Configuration</h3>
  </div>

  <div class="card mb-4">
    <div class="card-body">
      <h4>Account Information: <span id="accountInfo"></span></h4>
      <h3>Config List</h3>

      <!-- Config Table -->
      <div class="card mb-4">
        <div class="card-header d-flex justify-content-between align-items-center">
          <h4 class="card-title">Configs</h4>
          <button class="btn btn-outline-primary" onclick="addConfig()">Add Config</button>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped">
              <thead>
                <tr>
                  <th>Select</th>
                  <th>Message</th>
                  <th>Server</th>
                  <th>Channel</th>
                  <th>Delay (s)</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="configTableBody">
                <!-- Configs will be dynamically added here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Logs -->
      <h3>Logs</h3>
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <h4 class="card-title">Log Entries</h4>
          <button id="clearLogsBtn" class="btn btn-secondary">Clear Logs</button>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped">
              <thead>
                <tr>
                  <th>Time</th>
                  <th>Server</th>
                  <th>Channel</th>
                  <th>Delay (s)</th>
                  <th>Response</th>
                </tr>
              </thead>
              <tbody id="logTableBody">
                <!-- Logs will be dynamically added here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Start/Stop Buttons in one row -->
      <div class="d-flex align-items-center gap-2" style="margin-top: 1.5rem;">
        <button id="startBtn" class="btn btn-success" onclick="handleStartClick()">
          Start
        </button>
        <button id="stopBtn" class="btn btn-danger" onclick="handleStopClick()">
          Stop
        </button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.7.0/dist/sweetalert2.all.min.js"></script>
  <script>
    // All configs from DB
    let botConfigs = [];
    // The user-checked configs in the UI
    let selectedConfigs = [];
    // The configs currently auto-posting
    let runningConfigs = [];
    // Map of channelID -> setInterval ID
    let intervals = {};

    let currentAuthToken = "";

    // Toast utility
    const showToast = Swal.mixin({
      toast: true,
      position: "top-end",
      showConfirmButton: false,
      timer: 3000,
      timerProgressBar: true,
      didOpen: (toast) => {
        toast.onmouseenter = Swal.stopTimer;
        toast.onmouseleave = Swal.resumeTimer;
      },
    });

    // Confirm dialog
    const confirmAction = (title, text) =>
      Swal.fire({
        title,
        text,
        icon: "warning",
        showCancelButton: true,
        confirmButtonColor: "#3085d6",
        cancelButtonColor: "#d33",
        confirmButtonText: "Yes",
      });

    document.getElementById("clearLogsBtn").addEventListener("click", clearLogs);

    // ------------------ Fetch Channel & Server Info ------------------
    async function getChannelAndServerName(authToken, channelID) {
      try {
        const channelRes = await fetch(
          `https://discord.com/api/v10/channels/${channelID}`,
          {
            headers: { Authorization: authToken },
          }
        );
        if (!channelRes.ok) throw new Error("Could not fetch channel info");
        const channelData = await channelRes.json();

        const channelName = channelData.name || channelID;
        let serverName = "Unknown";
        if (channelData.guild_id) {
          const guildRes = await fetch(
            `https://discord.com/api/v10/guilds/${channelData.guild_id}`,
            {
              headers: { Authorization: authToken },
            }
          );
          if (guildRes.ok) {
            const guildData = await guildRes.json();
            serverName = guildData.name || "Unknown Server";
          }
        } else {
          // Possibly a DM or group channel
          serverName = "DM / No Guild";
        }
        return { channelName, serverName };
      } catch (err) {
        return { channelName: channelID, serverName: "Unknown" };
      }
    }

    // ------------------ Adding & Editing Configs ------------------
    async function addConfig() {
      const { value: config } = await Swal.fire({
        title: "Add Config",
        html: `
          <textarea id="message" class="swal2-textarea" placeholder="Message"></textarea>
          <input id="channelID" class="swal2-input" placeholder="Channel ID" type="number">
          <input id="delay" class="swal2-input" placeholder="Delay (s)" type="number">
        `,
        focusConfirm: false,
        preConfirm: () => validateConfig(),
      });

      if (config) {
        const { channelName, serverName } = await getChannelAndServerName(
          currentAuthToken,
          config.channelID
        );
        config.channelName = channelName;
        config.serverName = serverName;

        botConfigs.push(config);
        updateConfigTable();
        saveConfigs();
        showToast.fire({ icon: "success", title: "Config added" });
      }
    }

    async function editConfig(index) {
      const oldConfig = botConfigs[index];
      const { value: newConfig } = await Swal.fire({
        title: "Edit Config",
        html: `
          <textarea id="edit-message" class="swal2-textarea" placeholder="Message">${oldConfig.message}</textarea>
          <input id="edit-channelID" class="swal2-input" placeholder="Channel ID" type="number" value="${oldConfig.channelID}">
          <input id="edit-delay" class="swal2-input" placeholder="Delay (s)" type="number" value="${oldConfig.delay}">
        `,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: "Save Changes",
        preConfirm: () => validateConfig("edit-"),
      });

      if (newConfig) {
        // If channelID changed, re-fetch names
        if (newConfig.channelID !== oldConfig.channelID) {
          const { channelName, serverName } = await getChannelAndServerName(
            currentAuthToken,
            newConfig.channelID
          );
          newConfig.channelName = channelName;
          newConfig.serverName = serverName;
        } else {
          // keep old names
          newConfig.channelName = oldConfig.channelName;
          newConfig.serverName = oldConfig.serverName;
        }

        botConfigs[index] = newConfig;

        // If oldConfig was selected, replace it in selectedConfigs
        if (selectedConfigs.includes(oldConfig)) {
          selectedConfigs = selectedConfigs.filter((c) => c !== oldConfig);
          selectedConfigs.push(newConfig);
        }
        // If oldConfig was running, keep it running with the new data
        if (runningConfigs.includes(oldConfig)) {
          // Stop old one
          stopChannel(oldConfig);
          // Start new one
          startChannel(newConfig);
          runningConfigs = runningConfigs.filter((c) => c !== oldConfig);
          runningConfigs.push(newConfig);
        }

        updateConfigTable();
        saveConfigs();
        showToast.fire({ icon: "success", title: "Config updated" });
      }
    }

    // Validate user input in the add/edit modals
    function validateConfig(prefix = "") {
      const message = document.getElementById(prefix + "message").value.trim();
      const channelID = document.getElementById(prefix + "channelID").value.trim();
      const delaySeconds = parseInt(
        document.getElementById(prefix + "delay").value.trim(),
        10
      );

      if (!message || !channelID || isNaN(delaySeconds)) {
        Swal.showValidationMessage("All fields are required");
        return false;
      }
      if (delaySeconds < 1) {
        Swal.showValidationMessage("Delay must be at least 1 second");
        return false;
      }
      return { message, channelID, delay: delaySeconds };
    }

    // ------------------ Deleting Config ------------------
    function deleteConfig(index) {
      confirmAction("Delete Config", "Are you sure?").then((result) => {
        if (result.isConfirmed) {
          const removed = botConfigs.splice(index, 1)[0];
          // If removed config was selected, remove it from selectedConfigs
          selectedConfigs = selectedConfigs.filter((c) => c !== removed);
          // If it was running, stop it
          if (runningConfigs.includes(removed)) {
            stopChannel(removed);
          }
          updateConfigTable();
          saveConfigs();
          showToast.fire({ icon: "success", title: "Config deleted" });
        }
      });
    }

    // ------------------ Selection Logic ------------------
    function toggleConfigSelection(index, isSelected) {
      const config = botConfigs[index];
      if (isSelected) {
        // Add to selectedConfigs if not already there
        if (!selectedConfigs.includes(config)) {
          selectedConfigs.push(config);
        }
      } else {
        // Remove from selectedConfigs
        selectedConfigs = selectedConfigs.filter((c) => c !== config);
        // "Fix auto post is not active when unselect":
        // If it's running, stop it
        if (runningConfigs.includes(config)) {
          stopChannel(config);
        }
      }
      updateConfigTable();
    }

    // ------------------ Start/Stop Buttons ------------------
    function handleStartClick() {
      if (selectedConfigs.length === 0) {
        Swal.fire("Error", "Select at least one config", "error");
        return;
      }
      // Start intervals for all currently selected
      selectedConfigs.forEach((config) => {
        if (!runningConfigs.includes(config)) {
          startChannel(config);
        }
      });
      // "If the button has been clicked, it automatically unselects the channel."
      selectedConfigs = [];
      updateConfigTable();
      saveAutoPostState("started");
      showToast.fire({ icon: "success", title: "Auto post started" });
    }

    function handleStopClick() {
      if (selectedConfigs.length === 0) {
        Swal.fire("Error", "Select at least one config to stop", "error");
        return;
      }
      // Stop intervals only for the currently selected
      selectedConfigs.forEach((config) => {
        if (runningConfigs.includes(config)) {
          stopChannel(config);
        }
      });
      // auto-unselect after stopping
      selectedConfigs = [];
      updateConfigTable();
      saveAutoPostState("stopped");
      showToast.fire({ icon: "success", title: "Auto post stopped" });
    }

    // ------------------ Start/Stop Single Channel ------------------
    function startChannel(config) {
      // Immediately send one message
      sendMessage(config);

      // Then schedule repeated sends
      const intervalId = setInterval(() => sendMessage(config), config.delay * 1000);
      intervals[config.channelID] = intervalId;
      runningConfigs.push(config);
    }

    function stopChannel(config) {
      const intervalId = intervals[config.channelID];
      if (intervalId) {
        clearInterval(intervalId);
        delete intervals[config.channelID];
      }
      runningConfigs = runningConfigs.filter((c) => c !== config);
    }

    // ------------------ Sending & Logging ------------------
    function sendMessage(config) {
      fetch(`https://discord.com/api/v10/channels/${config.channelID}/messages`, {
        method: "POST",
        headers: {
          Authorization: currentAuthToken,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ content: config.message }),
      })
        .then((response) => response.json())
        .then((data) => {
          const status = data.id ? "Success" : "Failed";
          logMessage(config, status);
        })
        .catch((error) => {
          console.error("Error:", error);
          logMessage(config, "Error");
        });
    }

    function logMessage(config, response) {
      const row = document.createElement("tr");
      row.innerHTML = `
        <td>${new Date().toLocaleTimeString()}</td>
        <td>${config.serverName || "Unknown"}</td>
        <td>${config.channelName || config.channelID}</td>
        <td>${config.delay}</td>
        <td>${response}</td>
      `;
      document.getElementById("logTableBody").appendChild(row);
    }

    function clearLogs() {
      const logTableBody = document.getElementById("logTableBody");
      if (!logTableBody || logTableBody.children.length < 1) {
        showToast.fire({ icon: "info", title: "No logs to clear" });
        return;
      }
      confirmAction("Clear Logs", "This will clear all logs!").then((result) => {
        if (result.isConfirmed) {
          logTableBody.innerHTML = "";
          showToast.fire({ icon: "success", title: "Logs cleared" });
        }
      });
    }

    // ------------------ Table Rendering ------------------
    function updateConfigTable() {
      const tbody = document.getElementById("configTableBody");
      tbody.innerHTML = "";

      botConfigs.forEach((config, index) => {
        // A config is "selected" if it's in selectedConfigs
        const isSelected = selectedConfigs.includes(config);
        // A config is "running" if it's in runningConfigs
        const isRunning = runningConfigs.includes(config);

        const row = document.createElement("tr");
        row.innerHTML = `
          <td>
            <input 
              type="checkbox" 
              onchange="toggleConfigSelection(${index}, this.checked)"
              ${isSelected ? "checked" : ""} 
            />
          </td>
          <td title="${config.message}">${truncateText(config.message, 20)}</td>
          <td>${config.serverName || "Unknown"}</td>
          <td>${config.channelName || config.channelID}</td>
          <td>${config.delay}</td>
          <td>
            <button class="btn btn-info btn-sm me-2" onclick="editConfig(${index})">Edit</button>
            <button class="btn btn-danger btn-sm me-2" onclick="deleteConfig(${index})">
              <i class="fas fa-trash-alt"></i>
            </button>
            <span class="badge ${
              isRunning ? "bg-success" : "bg-danger"
            }">${isRunning ? "Active" : "Inactive"}</span>
          </td>
        `;
        tbody.appendChild(row);
      });
    }

    // ------------------ DB Interaction ------------------
    function saveConfigs() {
      fetch(`/conf/${currentAuthToken}/save-configs`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ configs: botConfigs }),
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) console.error("Failed to save configs");
        })
        .catch((error) => console.error("Error:", error));
    }

    function saveAutoPostState(state) {
      fetch(`/conf/${currentAuthToken}/save-auto-post-state`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ state }),
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            console.error("Failed to save auto-post state");
          }
        })
        .catch((error) => console.error("Error:", error));
    }

    async function loadConfigs() {
      try {
        const response = await fetch(`/conf/${currentAuthToken}/load-configs`);
        const data = await response.json();

        if (data.success) {
          botConfigs = Array.isArray(data.configs) ? data.configs : [];

          // fetch channel/server names if missing
          for (const config of botConfigs) {
            if (!config.channelName || !config.serverName) {
              const { channelName, serverName } = await getChannelAndServerName(
                currentAuthToken,
                config.channelID
              );
              config.channelName = channelName;
              config.serverName = serverName;
            }
          }
          updateConfigTable();

          // If previously started, do nothing or show a note
          if (data.autoPostState === "started") {
            showToast.fire({
              icon: "info",
              title:
                "Auto post was previously active. Select configs & press Start to resume or stop as needed.",
            });
          }
        } else {
          console.error("Failed to load configs:", data.message || "Unknown error");
        }
      } catch (error) {
        console.error("Error loading configs:", error);
      }
    }

    // ------------------ Helpers ------------------
    function truncateText(text, maxLength) {
      return text.length <= maxLength
        ? text
        : text.substr(0, maxLength - 3) + "...";
    }

    // ------------------ Initialization ------------------
    const urlParts = window.location.pathname.split("/");
    currentAuthToken = urlParts[urlParts.length - 1];
    if (!currentAuthToken) {
      Swal.fire({
        icon: "error",
        title: "Invalid Auth Token",
        text: "Redirecting to main page...",
        timer: 2000,
        timerProgressBar: true,
      }).then(() => {
        window.location.href = "/";
      });
    } else {
      loadConfigs();
    }
  </script>
</body>
</html>